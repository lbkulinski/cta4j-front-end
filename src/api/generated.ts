/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import {
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

/**
 * Represents a CTA train station with its unique identifier and display name.
 */
export interface TrainStation {
  /** Unique identifier for the CTA station, as provided in the official CTA data feed. */
  id: number;
  /** Display name of the station, which may include served transit lines in parentheses. */
  name: string;
}

/**
 * Route the train is serving, identified by its CTA route code.
 */
export type TrainArrivalRoute = typeof TrainArrivalRoute[keyof typeof TrainArrivalRoute];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TrainArrivalRoute = {
  RED: 'RED',
  BLUE: 'BLUE',
  BROWN: 'BROWN',
  GREEN: 'GREEN',
  ORANGE: 'ORANGE',
  PURPLE: 'PURPLE',
  PINK: 'PINK',
  YELLOW: 'YELLOW',
  N_A: 'N_A',
} as const;

/**
 * Represents a predicted CTA train arrival at a specific station and stop.
 */
export interface TrainArrival {
  /** CTA station ID where the train will arrive, from the official data feed. */
  stationId: number;
  /** CTA stop ID within the station, indicating the specific platform or boarding location. */
  stopId: number;
  /** Name of the station where the train will arrive. */
  stationName: string;
  /** Description of the stop or platform, often including travel direction. */
  stopDescription: string;
  /** Unique run number assigned to the train for tracking. */
  run: number;
  /** Route the train is serving, identified by its CTA route code. */
  route: TrainArrivalRoute;
  /** Stop ID for the train‚Äôs destination. */
  destinationStopId: number;
  /** Name of the train‚Äôs destination station. */
  destinationName: string;
  /** Numeric code representing the direction of travel. */
  direction: number;
  /** Time when the prediction was generated, in UTC. */
  predictionTime: string;
  /** Predicted time when the train will arrive at the stop, in UTC. */
  arrivalTime: string;
  /** Indicates whether the train is currently approaching the station. */
  approaching: boolean;
  /** Indicates whether this arrival is based on a scheduled timetable rather than real-time tracking. */
  scheduled: boolean;
  /** Indicates whether the train is experiencing a schedule fault or disruption. */
  faulted: boolean;
  /** Indicates whether the train is delayed beyond its scheduled or predicted arrival. */
  delayed: boolean;
  /** Latitude of the train's current location, in decimal degrees. */
  latitude: number;
  /** Longitude of the train's current location, in decimal degrees. */
  longitude: number;
  /** Compass heading of the train in degrees, where 0 is north. */
  heading: number;
  /** Minutes until arrival, rounded down. 0 means Due. */
  etaMinutes: number;
  /** Human-friendly ETA: 'Due' when ‚â§ 1 minute, otherwise 'Xm'. */
  etaLabel: string;
}

/**
 * Represents a CTA bus route with its unique identifier and display name.
 */
export interface BusRoute {
  /** Unique identifier for the CTA bus route, as provided in the official CTA data feed. */
  id: string;
  /** Display name of the bus route, which may include service type or destination details. */
  name: string;
}

/**
 * Type of prediction for this stop (arrival or departure), as provided in the CTA data feed.
 */
export type BusArrivalPredictionType = typeof BusArrivalPredictionType[keyof typeof BusArrivalPredictionType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BusArrivalPredictionType = {
  ARRIVAL: 'ARRIVAL',
  DEPARTURE: 'DEPARTURE',
} as const;

/**
 * Real-time passenger load category reported for the bus.
 */
export type BusArrivalPassengerLoad = typeof BusArrivalPassengerLoad[keyof typeof BusArrivalPassengerLoad];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BusArrivalPassengerLoad = {
  FULL: 'FULL',
  HALF_EMPTY: 'HALF_EMPTY',
  EMPTY: 'EMPTY',
  N_A: 'N_A',
} as const;

/**
 * Flag-stop behavior for this prediction.
 */
export type BusArrivalFlagStop = typeof BusArrivalFlagStop[keyof typeof BusArrivalFlagStop];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BusArrivalFlagStop = {
  UNDEFINED: 'UNDEFINED',
  NORMAL: 'NORMAL',
  PICKUP_AND_DISCHARGE: 'PICKUP_AND_DISCHARGE',
  ONLY_DISCHARGE: 'ONLY_DISCHARGE',
} as const;

/**
 * Represents a predicted CTA bus arrival at a specific stop.
 */
export interface BusArrival {
  /** Type of prediction for this stop (arrival or departure), as provided in the CTA data feed. */
  predictionType: BusArrivalPredictionType;
  /** Unique identifier for the CTA bus stop, as provided in the official CTA data feed. */
  stopId: string;
  /** Name of the stop where the bus will arrive. */
  stopName: string;
  /** Unique ID of the vehicle associated with this prediction. */
  vehicleId: number;
  /** Linear distance remaining to the stop, in feet. */
  distanceToStop: number;
  /** Alphanumeric route designator. */
  route: string;
  /** Direction of travel for the route, as provided in the CTA data feed. */
  routeDirection: string;
  /** Final destination for the bus associated with this prediction. */
  destination: string;
  /** Predicted time when the bus will arrive at the stop, in UTC. */
  arrivalTime: string;
  /** Indicates whether the bus is delayed beyond its scheduled or predicted arrival. */
  delayed: boolean;
  /** Indicates whether a dynamic action applies to this prediction. */
  dynamicActions: boolean;
  /** Service zone name if the bus is within a defined zone; otherwise empty. */
  zone: string;
  /** Real-time passenger load category reported for the bus. */
  passengerLoad: BusArrivalPassengerLoad;
  /** Flag-stop behavior for this prediction. */
  flagStop: BusArrivalFlagStop;
  /** Minutes until arrival, rounded down. 0 means Due. */
  etaMinutes: number;
  /** Human-friendly ETA: 'Due' when ‚â§ 1 minute, otherwise 'Xm'. */
  etaLabel: string;
}

/**
 * Represents a CTA bus stop with its unique identifier and display name.
 */
export interface BusStop {
  /** Unique identifier for the CTA bus stop, as provided in the official CTA data feed. */
  id: string;
  /** Display name of the bus stop, which may include the intersection or landmark name. */
  name: string;
}

/**
 * Represents a travel direction for a specific CTA bus route.
 */
export interface BusRouteDirection {
  /** Unique identifier for the CTA bus route, as provided in the official CTA data feed. */
  routeId?: string;
  /** Direction of travel for the route, as provided in the official CTA data feed. */
  direction?: string;
}

/**
 * Represents a CTA bus detour, including its status, affected routes/directions, and time window.
 */
export interface BusDetour {
  /** Unique identifier for the detour, as provided by CTA. */
  id: string;
  /** Version number of this detour record for tracking updates. */
  version: number;
  /** Indicates whether the detour is currently active. */
  active: boolean;
  /** Description or label for the detour, as provided in the CTA data feed. */
  description: string;
  routeDirections?: BusRouteDirection[];
  /** Time when the detour begins, in UTC. */
  startDate: string;
  /** Time when the detour ends, in UTC. */
  endDate: string;
}

/**
 * Returns a list of all train stations available in the system.
 * @summary Retrieve all train stations
 */
export const getStations = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TrainStation[]>> => {
    
    
    return axios.default.get(
      `/api/trains/stations`,options
    );
  }


export const getGetStationsQueryKey = () => {
    return [`/api/trains/stations`] as const;
    }

    
export const getGetStationsQueryOptions = <TData = Awaited<ReturnType<typeof getStations>>, TError = AxiosError<null>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStations>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStationsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStations>>> = ({ signal }) => getStations({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStations>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetStationsQueryResult = NonNullable<Awaited<ReturnType<typeof getStations>>>
export type GetStationsQueryError = AxiosError<null>


export function useGetStations<TData = Awaited<ReturnType<typeof getStations>>, TError = AxiosError<null>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStations>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStations>>,
          TError,
          Awaited<ReturnType<typeof getStations>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetStations<TData = Awaited<ReturnType<typeof getStations>>, TError = AxiosError<null>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStations>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStations>>,
          TError,
          Awaited<ReturnType<typeof getStations>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetStations<TData = Awaited<ReturnType<typeof getStations>>, TError = AxiosError<null>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStations>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve all train stations
 */

export function useGetStations<TData = Awaited<ReturnType<typeof getStations>>, TError = AxiosError<null>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStations>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetStationsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns a list of upcoming train arrivals for the specified station ID.
 * @summary Retrieve upcoming train arrivals at a specific station
 */
export const getArrivals = (
    stationId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TrainArrival[]>> => {
    
    
    return axios.default.get(
      `/api/trains/stations/${stationId}/arrivals`,options
    );
  }


export const getGetArrivalsQueryKey = (stationId?: string,) => {
    return [`/api/trains/stations/${stationId}/arrivals`] as const;
    }

    
export const getGetArrivalsQueryOptions = <TData = Awaited<ReturnType<typeof getArrivals>>, TError = AxiosError<null | null>>(stationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArrivals>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetArrivalsQueryKey(stationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getArrivals>>> = ({ signal }) => getArrivals(stationId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(stationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getArrivals>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetArrivalsQueryResult = NonNullable<Awaited<ReturnType<typeof getArrivals>>>
export type GetArrivalsQueryError = AxiosError<null | null>


export function useGetArrivals<TData = Awaited<ReturnType<typeof getArrivals>>, TError = AxiosError<null | null>>(
 stationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArrivals>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getArrivals>>,
          TError,
          Awaited<ReturnType<typeof getArrivals>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetArrivals<TData = Awaited<ReturnType<typeof getArrivals>>, TError = AxiosError<null | null>>(
 stationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArrivals>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getArrivals>>,
          TError,
          Awaited<ReturnType<typeof getArrivals>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetArrivals<TData = Awaited<ReturnType<typeof getArrivals>>, TError = AxiosError<null | null>>(
 stationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArrivals>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve upcoming train arrivals at a specific station
 */

export function useGetArrivals<TData = Awaited<ReturnType<typeof getArrivals>>, TError = AxiosError<null | null>>(
 stationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArrivals>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetArrivalsQueryOptions(stationId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns a list of all available bus routes in the system.
 * @summary Retrieve all bus routes
 */
export const getRoutes = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BusRoute[]>> => {
    
    
    return axios.default.get(
      `/api/buses/routes`,options
    );
  }


export const getGetRoutesQueryKey = () => {
    return [`/api/buses/routes`] as const;
    }

    
export const getGetRoutesQueryOptions = <TData = Awaited<ReturnType<typeof getRoutes>>, TError = AxiosError<null>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoutesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoutes>>> = ({ signal }) => getRoutes({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoutes>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRoutesQueryResult = NonNullable<Awaited<ReturnType<typeof getRoutes>>>
export type GetRoutesQueryError = AxiosError<null>


export function useGetRoutes<TData = Awaited<ReturnType<typeof getRoutes>>, TError = AxiosError<null>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutes>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoutes>>,
          TError,
          Awaited<ReturnType<typeof getRoutes>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoutes<TData = Awaited<ReturnType<typeof getRoutes>>, TError = AxiosError<null>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutes>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoutes>>,
          TError,
          Awaited<ReturnType<typeof getRoutes>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoutes<TData = Awaited<ReturnType<typeof getRoutes>>, TError = AxiosError<null>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutes>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve all bus routes
 */

export function useGetRoutes<TData = Awaited<ReturnType<typeof getRoutes>>, TError = AxiosError<null>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutes>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRoutesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns a list of upcoming bus arrivals for the specified route and stop.
 * @summary Retrieve upcoming bus arrivals at a specific stop
 */
export const getArrivals1 = (
    routeId: string,
    stopId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BusArrival[]>> => {
    
    
    return axios.default.get(
      `/api/buses/routes/${routeId}/stops/${stopId}/arrivals`,options
    );
  }


export const getGetArrivals1QueryKey = (routeId?: string,
    stopId?: string,) => {
    return [`/api/buses/routes/${routeId}/stops/${stopId}/arrivals`] as const;
    }

    
export const getGetArrivals1QueryOptions = <TData = Awaited<ReturnType<typeof getArrivals1>>, TError = AxiosError<null | null>>(routeId: string,
    stopId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArrivals1>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetArrivals1QueryKey(routeId,stopId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getArrivals1>>> = ({ signal }) => getArrivals1(routeId,stopId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(routeId && stopId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getArrivals1>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetArrivals1QueryResult = NonNullable<Awaited<ReturnType<typeof getArrivals1>>>
export type GetArrivals1QueryError = AxiosError<null | null>


export function useGetArrivals1<TData = Awaited<ReturnType<typeof getArrivals1>>, TError = AxiosError<null | null>>(
 routeId: string,
    stopId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArrivals1>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getArrivals1>>,
          TError,
          Awaited<ReturnType<typeof getArrivals1>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetArrivals1<TData = Awaited<ReturnType<typeof getArrivals1>>, TError = AxiosError<null | null>>(
 routeId: string,
    stopId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArrivals1>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getArrivals1>>,
          TError,
          Awaited<ReturnType<typeof getArrivals1>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetArrivals1<TData = Awaited<ReturnType<typeof getArrivals1>>, TError = AxiosError<null | null>>(
 routeId: string,
    stopId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArrivals1>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve upcoming bus arrivals at a specific stop
 */

export function useGetArrivals1<TData = Awaited<ReturnType<typeof getArrivals1>>, TError = AxiosError<null | null>>(
 routeId: string,
    stopId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getArrivals1>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetArrivals1QueryOptions(routeId,stopId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the list of possible travel directions (e.g., 'Northbound', 'Southbound') for the specified bus route.
 * @summary Retrieve directions for a specific bus route
 */
export const getDirections = (
    routeId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string[]>> => {
    
    
    return axios.default.get(
      `/api/buses/routes/${routeId}/directions`,options
    );
  }


export const getGetDirectionsQueryKey = (routeId?: string,) => {
    return [`/api/buses/routes/${routeId}/directions`] as const;
    }

    
export const getGetDirectionsQueryOptions = <TData = Awaited<ReturnType<typeof getDirections>>, TError = AxiosError<null | null>>(routeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDirections>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDirectionsQueryKey(routeId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDirections>>> = ({ signal }) => getDirections(routeId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(routeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDirections>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDirectionsQueryResult = NonNullable<Awaited<ReturnType<typeof getDirections>>>
export type GetDirectionsQueryError = AxiosError<null | null>


export function useGetDirections<TData = Awaited<ReturnType<typeof getDirections>>, TError = AxiosError<null | null>>(
 routeId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDirections>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDirections>>,
          TError,
          Awaited<ReturnType<typeof getDirections>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDirections<TData = Awaited<ReturnType<typeof getDirections>>, TError = AxiosError<null | null>>(
 routeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDirections>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDirections>>,
          TError,
          Awaited<ReturnType<typeof getDirections>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDirections<TData = Awaited<ReturnType<typeof getDirections>>, TError = AxiosError<null | null>>(
 routeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDirections>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve directions for a specific bus route
 */

export function useGetDirections<TData = Awaited<ReturnType<typeof getDirections>>, TError = AxiosError<null | null>>(
 routeId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDirections>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDirectionsQueryOptions(routeId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns a list of bus stops for the specified route and travel direction.
 * @summary Retrieve stops for a specific bus route and direction
 */
export const getStops = (
    routeId: string,
    direction: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BusStop[]>> => {
    
    
    return axios.default.get(
      `/api/buses/routes/${routeId}/directions/${direction}/stops`,options
    );
  }


export const getGetStopsQueryKey = (routeId?: string,
    direction?: string,) => {
    return [`/api/buses/routes/${routeId}/directions/${direction}/stops`] as const;
    }

    
export const getGetStopsQueryOptions = <TData = Awaited<ReturnType<typeof getStops>>, TError = AxiosError<null | null>>(routeId: string,
    direction: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStops>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStopsQueryKey(routeId,direction);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStops>>> = ({ signal }) => getStops(routeId,direction, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(routeId && direction), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStops>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetStopsQueryResult = NonNullable<Awaited<ReturnType<typeof getStops>>>
export type GetStopsQueryError = AxiosError<null | null>


export function useGetStops<TData = Awaited<ReturnType<typeof getStops>>, TError = AxiosError<null | null>>(
 routeId: string,
    direction: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStops>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStops>>,
          TError,
          Awaited<ReturnType<typeof getStops>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetStops<TData = Awaited<ReturnType<typeof getStops>>, TError = AxiosError<null | null>>(
 routeId: string,
    direction: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStops>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStops>>,
          TError,
          Awaited<ReturnType<typeof getStops>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetStops<TData = Awaited<ReturnType<typeof getStops>>, TError = AxiosError<null | null>>(
 routeId: string,
    direction: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStops>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve stops for a specific bus route and direction
 */

export function useGetStops<TData = Awaited<ReturnType<typeof getStops>>, TError = AxiosError<null | null>>(
 routeId: string,
    direction: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStops>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetStopsQueryOptions(routeId,direction,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns a list of active detours affecting the specified bus route and travel direction.
 * @summary Retrieve active detours for a specific bus route and direction
 */
export const getDetours = (
    routeId: string,
    direction: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BusDetour[]>> => {
    
    
    return axios.default.get(
      `/api/buses/routes/${routeId}/directions/${direction}/detours`,options
    );
  }


export const getGetDetoursQueryKey = (routeId?: string,
    direction?: string,) => {
    return [`/api/buses/routes/${routeId}/directions/${direction}/detours`] as const;
    }

    
export const getGetDetoursQueryOptions = <TData = Awaited<ReturnType<typeof getDetours>>, TError = AxiosError<null | null>>(routeId: string,
    direction: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDetours>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDetoursQueryKey(routeId,direction);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDetours>>> = ({ signal }) => getDetours(routeId,direction, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(routeId && direction), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDetours>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDetoursQueryResult = NonNullable<Awaited<ReturnType<typeof getDetours>>>
export type GetDetoursQueryError = AxiosError<null | null>


export function useGetDetours<TData = Awaited<ReturnType<typeof getDetours>>, TError = AxiosError<null | null>>(
 routeId: string,
    direction: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDetours>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDetours>>,
          TError,
          Awaited<ReturnType<typeof getDetours>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDetours<TData = Awaited<ReturnType<typeof getDetours>>, TError = AxiosError<null | null>>(
 routeId: string,
    direction: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDetours>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDetours>>,
          TError,
          Awaited<ReturnType<typeof getDetours>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDetours<TData = Awaited<ReturnType<typeof getDetours>>, TError = AxiosError<null | null>>(
 routeId: string,
    direction: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDetours>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Retrieve active detours for a specific bus route and direction
 */

export function useGetDetours<TData = Awaited<ReturnType<typeof getDetours>>, TError = AxiosError<null | null>>(
 routeId: string,
    direction: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDetours>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDetoursQueryOptions(routeId,direction,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
